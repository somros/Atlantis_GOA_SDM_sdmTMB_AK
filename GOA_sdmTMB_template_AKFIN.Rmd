---
title: "Atlantis biomass distributions with sdmTMB - lat, lon, depth"
author: "Alberto Rovellini"
date: "6/21/2021"
output:
  html_document:
    code_folding: hide
    toc: true
    toc_float: true
---

# Purpose

**This document is based on Gemma's code.**

**Update 6/16/2021 after talking to Sean Anderson**

Sean recommended a few changes, so we will play around with thise here:
1. Do everything in projected coordinates instead of degrees.
2. Play around with cutoff argument to make the mesh, instead of number of knots.
3. Add max gradient for the checks of convergence. Read what this is about intuitively. 
4. Turn the model code to its default, with no extra optimization. Might put in a if statement, where if the gradient is too high we re-run it with some of those extra optimization routines to help convergence.
5. Optional: If we are bothered by 0 CPUE, we could bin data and predictions. I am inclined to skip this, best to show that the model does not get zeroes right, which seems normal for this type of models.
6. Optional: Have a look at the branch where Sean implemented the calculation of SD of the predictions (optional for now, I feel like we have enough sensible checks in place).

**Update 6/20/2021**
Because getting access to RACEBASE data and age-structured information, we have chosen to start from using the same distribution for juveniles and adults. This code reads data obtained from AKFIN.

This is a template for fitting sdmTMB to GOA bottom trawl data. For each species, it fits sdmTMB to AKFIN CPUE data (obtained from catch and effort information, see catch_to_cpue_AKFIN.Rmd) to predict CPUE in kg per km$^{2}$. This predicted CPUE is then scaled up to box area in Atlantis, to get biomass per box and proportion of the total by box, which is what we need to initialise Atlantis. This same code will be run for biomass pool species too, except for those we will not split inot juveniles and adults.

This workflow does not include British Columbia: biomasses and/or numbers of individuals for the Atlantis boxes in the Canadian part of the model will be estimated separately by using this code, with some adjustments, on DFO groundfish bottom trawl data. 

This workflow is based on the following assumptions:

1. We use lat, lon and depth as predictors. We do not use environmental covariates as predictors because we are not attempting to explain why fish species are distributed the way they are, but rather we are trying to have sensible generic distributions over the model domain throughout the study period (1984-2019).
2. We predict over a regular grid. The size of this grid is 10 km at the moment for computational efficiency, but this is arbitrary and we may need to test different grid sizes and see how the results change. After some testing with predicting over a grid of 1 point per Atlantis box, I chose to use a regular grid because: (1) an average value of lat and lon, such as a centroid, is difficult to calculate for some of the boxes with crescent shapes; and (2) some boxes are placed over areas where depth changes greatly (the GOA bathymetry is complex), and the inside points may fall inside or near a deeper/shallower area withih a certain box. While the Atlantis box itself has a constant depth, the nearest node of the SPDE mesh may have been near such deeper/shallower area, thus skewing the estimate of the biomass index for that particular box.
3. We are not so interested in accurate predictions for any one year, but rather in representative means of where the fish has been over the last few decades. This code runs a temporal model and takes averages of the estimates at the end.

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# Read data

This is CPUE data obtained from catch and effort data accessible on AKFIN. 

Note: for lat and lon, for now I am using the start values for each tow, but it would be easy to get the coordinates for the midpoint of the tow.
```{r}
fields <- c("YEAR",
            "HAULJOIN",
            "LAT", 
            "LON", 
            "DEPTHR", 
            "ATLANTIS_GROUP", 
            "CN",
            "BIOM_KGKM2", 
            "NUM_KM2")
  
race_data <- race_data %>% select(all_of(fields)) %>% set_names(c(
  "year",
  "hauljoin",
  "lat",
  "lon",
  "depth",
  "species_code",
  "name",
  "biom_kgkm2",
  "num_km2"))
```

Take a quick look at the data spatially.
```{r, fig.width = 12, fig.height = 18}
# coast for plotting
load("data/goa_coast.Rdata")
coast_sf <- st_as_sf(coast) # turn coast to sf

ggplot()+
  geom_point(data = race_data, aes(lon, lat, colour = log1p(biom_kgkm2)), size = 1.5)+
  scale_colour_viridis_c()+
  geom_polygon(data = coast, aes(x = long, y = lat, group = group), colour = "black", fill = "grey80")+
  theme_minimal()+
  facet_wrap(~year, ncol = 2)+
  labs(title = paste(race_data$name,"CPUE from GOA bottom trawl survey - stage:", race_data$stage, sep = " "))
```

Take a quick look at time series of total CPUE from raw data
```{r}
biom_year <- race_data %>% group_by(year) %>% summarise(biom = sum(log1p(biom_kgkm2)))

ggplot(biom_year, aes(year, log(biom)))+
  geom_point()+
  geom_path()+
  theme_minimal()+
  labs(title = paste(race_data$name,"total GOA CPUE from bottom /n trawl survey - stage:", race_data$stage, sep = " "))

```
The above is across the entire GOA. 

# Add zeroes for hauls with no catch

We need to add empty hauls (i.e., hauls where the catch for a given species is 0). To do this, I take haul information from the "Haul Descriptions" data set on AKFIN. I then subtract the AKFIN hauls with catch in race_data from the "Haul Descriptions" list to see which hauls were empty for this particular species / life stage. Then pad these empty hauls with zero CPUEs, and attach them to race_data.
```{r}
#load("data/hauls.Rdata") # as accessible on AKFIN Answers with no further modifications

data_hauls <- levels(factor(race_data$hauljoin))
zero_hauls <- setdiff(levels(factor(hauls$Haul.Join.ID)), data_hauls) # assuming that if there are no records from a haul, the catch in that haul was 0 for this species

# make a data frame to bind by row
zero_catches <- hauls %>% filter(Haul.Join.ID %in% zero_hauls) %>% 
  select(Year, Haul.Join.ID, Ending.Latitude..dd., Ending.Longitude..dd., Bottom.Depth..m.) %>% 
  mutate(species_code = rep(NA, length(Year)),
         name = rep(NA, length(Year)),
         biom_kgkm2 = rep(0, length(Year)),
         num_km2 = rep(0, length(Year))) %>%
  set_names(names(race_data))

# attach by row to race_data
race_data <- rbind(race_data, zero_catches)
# ditch hauls with empty lat or lon
race_data <- race_data %>% filter(!is.na(lat) | !is.na(lon))
# and with NA depths
race_data <- race_data %>% filter(!is.na(depth))
```

# sdmTMB

## Create spatial mesh

### Transform coordinates

The first step here will be to go from the native lat lon coordinates of the bottom trawl data to projected coordinates. Here we use the custom projection that is used by the Atlantis geometry "+proj=tmerc +lat_0=50 +lon_0=-154 +lat_1=55 +lat_2=65 +x_0=0 +y_0=0 +datum=WGS84 +units=m +no_defs". Note that this is still WGS84. May be worth comparing with NAD83. We used WGS84 because the Cehckwinding code did not seem to cope with NAD83. 

Read in the Atlantis BGM, then turn the bottom trawl data to an sf object, reproject it, and then turn it back to coordinates.
```{r}
#atlantis_bgm <- read_bgm("data/GOA_WGS84_V4_final.bgm")

race_data_sf <- race_data %>% st_as_sf(coords = c("lon", "lat"), crs = 4326) %>% st_transform(crs = atlantis_bgm$extra$projection)

# now extract coordinates, and divide by 1000 to transform m to km
race_coords <- race_data_sf %>% st_coordinates() %>% data.frame() %>% mutate(x=X/1000,y=Y/1000) %>% select(-X,-Y)

# turn sf back to a data frame
race_data <- race_data_sf %>% st_set_geometry(NULL) %>% data.frame(race_coords)
```
Using the "cutoff" argument, instead of predefining the number of points. This will help with AFSC vs DFO (use the same distance), also it does not depend on the random seed or on the order of the data. 

**Note:** SPDE = Stochastic Partial Differential Equations approach. Some material can be found [here](https://becarioprecario.bitbucket.io/spde-gitbook/ch-intro.html#sec:spde), but basically it is a way of calculating the position of the mesh knots. 

```{r}
race_spde <- make_mesh(race_data, c("x", "y"), cutoff = cutoff, type = "cutoff")
plot(race_spde)
race_spde$mesh$n
```

Check out the distribution of the biomass response variable.
```{r}
hist(race_data$biom_kgkm2, breaks = 30)
```

```{r}
hist(log1p(race_data$biom_kgkm2), breaks = 30)
```

Proportion of zeroes in percentage.
```{r}
length(which(race_data$biom_kgkm2 == 0))/nrow(race_data)*100
```

## Space, time, and depth model.

Try running a model with smooth term for depth. Using 5 knots for the smooth - but this is arbitrary and a range of values could be tested. As a note, I am not scaling depth here. The reason is that depth has a different range in the data and the prediction grid, and thus scaled values have different meaning between the two.

**Model type**: the distribution of the response variable plotted above should give a sense of what model is most appropriate. CPUE data for many of these species resemble a Tweedie distribution when log-transformed, so we use a Tweedie model with a log link. Some groups may warrant a different model, and this will be evaluated case-by-case depending on convergence issues, distribution of model residuals, and model skill metrics (see below).

```{r, results = FALSE}
start.time <- Sys.time()
m_depth <- sdmTMB(
  data = race_data, 
  formula = biom_kgkm2 ~ 0 + s(depth, k = 5) + as.factor(year), 
  time = "year", 
  spde = race_spde, 
  reml = TRUE,
  anisotropy = FALSE,
  spatial_trend = FALSE, 
  spatial_only = FALSE,
  silent = FALSE,
  control = sdmTMBcontrol(),
  # nlminb_loops = 3,
  # newton_steps = 10,
  family = tweedie(link = "log"))
end.time <- Sys.time()
time.taken_m_depth <- end.time - start.time
time.taken_m_depth
```

Rerun with extra optimization steps in case of gradient > 0.001. 
```{r, results = FALSE}
if(max(m_depth$gradients)>0.001){
  m_depth <- sdmTMB(
  data = race_data, 
  formula = biom_kgkm2 ~ 0 + s(depth, k = 5) + as.factor(year), 
  time = "year", 
  spde = race_spde, 
  reml = TRUE,
  anisotropy = FALSE,
  spatial_trend = FALSE, 
  spatial_only = FALSE,
  silent = FALSE,
  control = sdmTMBcontrol(),
  nlminb_loops = 1,
  newton_steps = 3,
  family = tweedie(link = "log"))
end.time <- Sys.time()
}
```

Check information on model convergence. From [the nlminb help page](https://rdrr.io/r/stats/nlminb.html) we know that an integer 0 indicates succesful convergence. Additional information on convergence can be checked with m_depth/$model/$message. According to the original [PORT optimization documentation](https://web.archive.org/web/20070203144320/http://netlib.bell-labs.com/cm/cs/cstr/153.pdf), "Desirable return codes are 3, 4, 5, and sometimes 6".  
```{r}
if(m_depth$model$convergence == 0){print("The model converged.")} else {print("Check convergence issue.")}
m_depth$model$message
max(m_depth$gradients)
m_depth$tmb_obj$report()$range
```
The range is a parameter that indicates the distance at which autocorrelation in the data drops to about 0.13. A large range means that spatial autocorrelation decays more slowly with distance. A smaller range will require more knots. The range can be obtained from the model object, but it always seems to be larger than the cutoff argunemt we choose to create the INLA mesh. Let's make sure that the range is always larger than the cutoff.

Interestingly, increasing the number of knots in the mesh does not necessarily seem to decrease the gradient. 

Check out model residuals. 
```{r}
race_data$resids <- residuals(m_depth) # randomized quantile residuals
hist(race_data$resids)
```

And QQ plot.
```{r}
qqnorm(race_data$resids)
abline(a = 0, b = 1)
```

Plot the response curve from the depth smooth term.
```{r}
plot(m_depth$mgcv_mod, rug = TRUE)
```

Finally, plot the residuals in space. If residuals are constantly larger/smaller in some of the areas, it may be sign that the model is biased and it over/underpredicts consistently for some areas. Residuals should be randomly distributed in space. 

For visualisation purposes, multiply the coordinates by 1000 in the sf object to restore the correct scale.
```{r, fig.width = 12, fig.height=18}
race_sf <- race_data %>% mutate(x = x*1000, y = y*1000) %>% st_as_sf(coords = c(x = "x", y = "y"), crs = atlantis_bgm$extra$projection) #%>% st_transform(crs = atlantis_bgm$extra$projection) # turn to spatial object

coast_sf <- coast_sf %>% st_transform(crs = atlantis_bgm$extra$projection)

ggplot()+
  geom_sf(data = race_sf, aes(color = resids, alpha = .8))+
  scale_color_viridis()+
  geom_sf(data = coast_sf)+
  theme_minimal()+
  labs(title = paste(race_data$name,"model residuals in space - stage:", race_data$stage, sep = " "))+
  facet_wrap(~year, ncol = 2)
```

# Predictions from SDM

Take a grid (which must contain information on the predictors we used to build the model) and predict the biomass index over such grid based on the predictors. 

1. The grid is currently a regular grid with 10-km cell size, but 10 km might not be enough to get prediction points in all boxes - especially for a couple very small and narrow boxes at the western end of the model domain. Revisit this if necessary, but a finer mesh could be difficult to justify compared to the density of the survey data. 
2. The grid covers the entire Atlantis model domain, including the non-dynamic boundary boxes (deeper than 1000 m). The grid at the moment also includes Canada boxes, although predictions for these boxes will not be considered here.

Read in the Atlantis prediction grid (10 km) modified in Atlantis_grid_covars.R (code not included here).
```{r}
atlantis_boxes <- atlantis_bgm %>% box_sf()
```

**Important:** depth in the RACE data is a positive number. Depth in the prediction grid we obtained from the ETOPO rasters is a negative number. When we use depth as predictor for in our regular grid, make sure depth is a positive number for consistency with the model variable, or else everything will be upside-down. This was done in the script that produces the prediction grid, so depth is **positive**. 
```{r}
atlantis_grid <- atlantis_grid_template

paste("Positive depths are:", length(which(atlantis_grid$depth>0)), "out of:", nrow(atlantis_grid_depth), sep = " ") # Write out a check that depths are positive (few negatives are OK - they are on land - I'll fix it but it should not matter as island boxes will be boundary boxes in Atlantis so predictions will not matter for those)

# add year column
all_years <- levels(factor(race_data$year))

atlantis_grid <- atlantis_grid[rep(1:nrow(atlantis_grid), length(all_years)),]
atlantis_grid$year <- as.integer(rep(all_years, each = nrow(atlantis_grid_depth)))
```

Visualise the prediction grid.
```{r}
coast_tmp <- map("worldHires", regions = c("Canada", "USA"), plot = FALSE, fill = TRUE)
coast_tmp <- coast_tmp %>% st_as_sf() %>% st_transform(crs = atlantis_bgm$extra$projection)

atlantis_grid %>% filter(year == 1984) %>%
  st_as_sf(coords = c("x", "y"), crs = atlantis_bgm$extra$projection) %>%
  ggplot()+
  geom_sf(size = 0.1)+
  geom_sf(data = coast_tmp)+
  coord_sf(xlim = c(-1160825.0,1799175.0), ylim = c(290420.6, 1799175.0))+ # -1160825.0   290420.6  1799175.0  1170420.6 
  theme_minimal()+
  labs(title = "Prediction grid")
```

Transform the coordinates, divide by 1000 to turn from m to km for consistency with the data.
```{r}
atlantis_grid <- atlantis_grid %>% mutate(x = x/1000, y = y/1000)
```

Make SDM predictions onto new data from depth model. **Back-transforming here**
```{r}
predictions_race <- predict(m_depth, newdata = atlantis_grid, return_tmb_object = TRUE)
atlantis_grid$estimates <- exp(predictions_race$data$est) #Back-transforming here

atlantis_grid_sf <- atlantis_grid %>% mutate(x=x*1000,y=y*1000) %>% st_as_sf(coords = c("x", "y"), crs = atlantis_bgm$extra$projection) # better for plots, multiplying the coordinates by 1000 for visualisation
```

Not plotting most of Canada because the predictions look terrible (due to not having biomass data from there in this model).
```{r,  fig.width = 12, fig.height = 18}
ggplot()+
  geom_sf(data = subset(atlantis_boxes, box_id < 92), aes(fill = NULL))+
  geom_sf(data = subset(atlantis_grid_sf, box_id < 92), aes(color=log1p(estimates)))+ # taking the log for visualisation
  geom_sf(data = coast_sf, colour = "black", fill = "grey80")+
  scale_color_viridis(name = expression(paste("Log(CPUE) kg ", km^-2)))+
  theme_minimal()+
  labs(title = paste(race_data$name,"predicted CPUE - stage:", race_data$stage, sep = " "))+
  facet_wrap(~year, ncol = 2)
```

Attribute the predictions to their respective Atlantis box, so that we can take box averages.
```{r}
atlantis_grid_means <- atlantis_grid %>% group_by(year, box_id) %>%
  summarise(mean_estimates = mean(estimates, na.rm = TRUE)) %>% ungroup() 

# join this with the box_sf file

predictions_by_box <- atlantis_boxes %>% inner_join(atlantis_grid_means, by = "box_id")
```

See estimates per box for all years. Silence boundary boxes as they throw the scale out of whack (and they do not need predictions). 
```{r, fig.width = 12, fig.height = 18}
predictions_by_box <- predictions_by_box %>% rowwise() %>% mutate(mean_estimates = ifelse(isTRUE(boundary), NA, mean_estimates))

ggplot()+
  geom_sf(data = predictions_by_box[predictions_by_box$box_id<92,], aes(fill = log1p(mean_estimates)))+ # taking the log for visualisation
  scale_fill_viridis(name = expression(paste("Log(CPUE) kg ", km^-2)))+
  theme_minimal()+
  geom_sf(data = coast_sf, colour = "black", fill = "grey80")+
  facet_wrap(~year, ncol = 2)+
  labs(title = paste(race_data$name, "mean predicted CPUE by Atlantis box - stage:", race_data$stage, sep = " "))
```

Plot the raw data again for comparison.
```{r, fig.width = 12, fig.height = 18}
ggplot()+
  geom_sf(data = race_data_sf, aes(colour = log1p(biom_kgkm2)), size = 1.5, alpha = .5)+
  scale_colour_viridis_c(name = expression(paste("Log(CPUE) kg ", km^-2)))+
  geom_sf(data = coast_sf, colour = "black", fill = "grey80")+
  theme_minimal()+
  facet_wrap(~year, ncol = 2)+
  labs(title = paste(race_data$name,"CPUE from GOA bottom trawl survey - stage:", race_data$stage, sep = " "))
```

Have a look at CPUE by depth. This is rough and quick, keep in mind that most tows happen shallower than 300 m, so the sample is not equal between depths.
```{r}
ggplot(data = race_data, aes(x = depth, y = log1p(biom_kgkm2), color = log1p(num_km2)))+
  scale_color_viridis()+
  geom_point()+
  theme_minimal()+
  labs(title = "CPUE by depth")
```

Plot data and predictions distributions. These are the data.
```{r}
ggplot(data = race_data, aes(x = log1p(biom_kgkm2)))+
  geom_histogram(colour = "black", fill = 'grey80', bins = 30)+
  theme_minimal()
```

And these are the predictions over the 10 km grid.
```{r}
ggplot(data = atlantis_grid, aes(x = log1p(estimates)))+
  geom_histogram(colour = "black", fill = 'grey80', bins = 30)+
  theme_minimal()
```

# Mean predictions for the study period

Now calculate means of the predictions for the entire study period. Doing it by taking 1984-2019 averages for each Atlantis box.
```{r, fig.width = 10, fig.height = 5}
means_all_years <- predictions_by_box %>% group_by(box_id, area, boundary) %>% summarise(all_years_kgkm2 = mean(mean_estimates)) %>% ungroup()

ggplot()+
  geom_sf(data = means_all_years[means_all_years$box_id < 92,], aes(fill = log1p(all_years_kgkm2)))+ # log for visualisation
  scale_fill_viridis(name = expression(paste("Log(CPUE) kg ", km^-2)))+
  geom_sf(data = coast_sf, colour = "black", fill = "grey80")+
  theme_minimal()+
  labs(title = paste(race_data$name, "mean predicted CPUE by Atlantis box (1984-2019) - stage:", race_data$stage, sep = " "))
```

Let's have a look at the variance per box over all years. We use the coefficient of variation, because CPUE varies widely between boxes.
```{r, fig.width = 10, fig.height = 5}
cv_all_years <- predictions_by_box %>% group_by(box_id, area, boundary) %>% summarise(cv = sd(mean_estimates)/mean(mean_estimates)) %>% ungroup()

ggplot()+
  geom_sf(data = cv_all_years[cv_all_years$box_id < 92,], aes(fill = cv))+ # log for visualisation
  scale_fill_viridis(name = "CV of CPUE")+
  geom_sf(data = coast_sf, colour = "black", fill = "grey80")+
  theme_minimal()+
  labs(title = paste(race_data$name, "CV of predicted CPUE by Atlantis box (1984-2019) - stage:", race_data$stage, sep = " "))
```
A couple of boxes have a pretty high CV. This will change between species. 

Let's see how estimated CPUE changes over time, per box.
```{r, fig.width = 12, fig.height = 18}
predictions_by_box %>% 
  ggplot(aes(x = year,y = mean_estimates))+
  geom_point()+
  geom_line()+
  theme_minimal()+
  facet_wrap(~.bx0, scales = "free", ncol = 8)
```

Considerable variation over time. It may be worth assigning more weight to earlier years, although the distributions are supposed to be "generally representative" throughout the simulation, at least when it comes to S1-S4.

# Model skill

Trying to evaluate model skill by having a look at how well model predictions align with observations.

Since this is a spatially-explicit approach, we need observations and predictions at the same location. We use the locations of all RACE hauls as a prediction grid.   
```{r}
#make a prediction grid from the race data itself
race_grid_tmp <- race_data %>% dplyr::select(x, y, depth)

# add year
race_grid <- race_grid_tmp[rep(1:nrow(race_grid_tmp), length(all_years)),]
race_grid$year <- as.integer(rep(all_years, each = nrow(race_grid_tmp)))

# predict on this grid
predictions_at_locations <- predict(m_depth, newdata = race_grid, return_tmb_object = TRUE)
race_grid$predictions <- exp(predictions_at_locations$data$est) # back-transforming here
```

Now join by year and coordinates to have predictions at the sampling points. 
```{r, fig.width = 12, fig.height = 6}
race_corr <- race_data %>% left_join(race_grid, by = c("year", "y", "x"))
```

## Observed versus predicted

```{r}
paste0("Pearson's coef observations vs predictions: ", cor(race_corr$biom_kgkm2, race_corr$predictions, use = "everything", method = "pearson"))
```

Plot.
```{r, fig.width = 12, fig.height = 12}
ggplot(race_corr, aes(x = log1p(biom_kgkm2), y = log1p(predictions)))+ # log for visualisation
  geom_point(aes(color = depth.y))+
  scale_color_viridis()+
  geom_abline(intercept = 0, slope = 1)+
  theme_minimal()+
  facet_wrap(~year, scales = "free")+
  labs(title = paste(race_data$name, "observed vs predicted CPUE. Stage: ", race_data$stage, sep = " "))
```

These models often underpredict zeroes, i.e. they predict a catch where there was none. Does this happen randomly in space? Does it have a correlation of some kind with depth?

Plot zero catch from the data and the relative predictions. Turn to sf for plotting.
```{r, fig.width = 12, fig.height = 18}
race_corr %>% filter(biom_kgkm2 == 0) %>%
  mutate(x=x*1000,y=y*1000) %>%
  st_as_sf(coords = c(x = "x", y = "y"), crs = atlantis_bgm$extra$projection) %>%
  ggplot()+
  geom_sf(aes(color = log1p(predictions)))+
  geom_sf(data = coast_sf)+
  scale_color_viridis()+
  theme_minimal()+
  labs(title = "Model predictions at zero-catch locations")+
  facet_wrap(~year, ncol = 2)
```

What about the relationship between model residuals and depth?
```{r, fig.width = 12, fig.height=16}
race_data %>%
  ggplot()+
  geom_point(aes(x = depth, y = resids, color = log1p(biom_kgkm2)))+
  geom_hline(yintercept = 0, color = "red", linetype = "dashed")+
  scale_color_viridis()+
  theme_minimal()+
  facet_wrap(~year, ncol = 2)
```

There does not seem to be an obvious relationship between depth and residuals. 

## Root Mean Square Error (RMSE)

Calculate RMSE between predicted and observed values.
```{r}
paste("RMSE:", sqrt(sum((race_corr$predictions - race_corr$biom_kgkm2)^2)/nrow(race_corr)), " kg km-2", sep = " ") ### traditional rmse metric, in units kg km2
```

Normalised RMSE. 
```{r}
rmse_cv <- sqrt(sum((race_corr$predictions - race_corr$biom_kgkm2)^2)/nrow(race_corr))/(max(race_corr$biom_kgkm2)-min(race_corr$biom_kgkm2))*100 #### normalised rmse, expressed as a % of the range of observed biomass values, sort of approximates a coefficient of variation 
paste("Normalised RMSE:", paste0(rmse_cv, "%"), sep = " ")
```

# Total biomass and biomass per box

The current estimated CPUE is in kg km$^{-2}$. So, just we just turn that into biomass per box. Remember that the area is in m$^2$ for the boxes, so need to divide by 1,000,000.

Do this separate for Alaska and Canada, since we are using different data. Total biomass to calculate only for the respective regions, as well as box biomass. Proportional biomass (S1-S4), instead, makes sense only for the entire model domain, so that will be in another script.
```{r}
means_all_years <- means_all_years %>% mutate(biomass = all_years_kgkm2*area*1e-06*1e-03) # dividing by 1000 to get tons instead of kg

means_alaska <- means_all_years %>% filter(box_id<92)
```

```{r}
means_alaska %>% select(box_id, all_years_kgkm2, biomass) %>% st_set_geometry(NULL) %>% kable(align = 'lccc', format = "markdown", 
      col.names = c("Box", "CPUE (kg km-2)", "Biomass (mt)"))
```

Write out a .csv.
```{r}
out <- means_alaska %>% st_set_geometry(NULL)

write.csv(x = out, file = paste0("C:/Users/arove/Documents/GOA/SDM/sdmTMB_forGemma_May2021/output/cpue_tables/",race_data$name[1],"_AFSC.csv"), row.names = FALSE)
```

# Validation metrics

Let's produce a table that includes: convergence metrics; Pearson's correlation coefficient for predicted vs observed; RMSE; and normalised RMSE. 

```{r}
data.frame(m_depth$model$convergence, # convergence
           m_depth$model$message, # more convergence
           max(m_depth$gradients), # max gradient
           m_depth$tmb_obj$report()$range, # practical range
           cor(race_corr$biom_kgkm2, race_corr$predictions, use = "everything", method = "pearson"), # correlation
           sqrt(sum((race_corr$predictions - race_corr$biom_kgkm2)^2)/nrow(race_corr)),# RMSE
           sqrt(sum((race_corr$predictions - race_corr$biom_kgkm2)^2)/nrow(race_corr))/(max(race_corr$biom_kgkm2)-min(race_corr$biom_kgkm2))*100 # NRMSE
) %>% set_names(c("Convergence","Message","Max gradient","Practical range (km)","Pearson's correlation","RMSE","NRMSE(%)"))

```
